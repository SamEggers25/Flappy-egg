<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Flappy Egg</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Fredoka+One&family=Quicksand:wght@400;700&display=swap" rel="stylesheet">
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <style>
      body {
        margin: 0;
        padding: 0;
        overflow: hidden;
        background-color: #f0f9ff;
        font-family: 'Quicksand', sans-serif;
      }
      .font-game {
        font-family: 'Fredoka One', cursive;
      }
    </style>
</head>
<body>
    <div id="root"></div>
    
    <script type="text/babel">
      const { useState, useEffect, useCallback, useRef } = React;

      // Constants
      const GRAVITY = 0.4;
      const JUMP_STRENGTH = -7.5;
      const PIPE_SPEED = 3.2;
      const PIPE_WIDTH = 60;
      const PIPE_GAP = 180;
      const EGG_RADIUS = 22;
      const GROUND_HEIGHT = 100;
      const SHAKE_INTENSITY = 10;

      const KNIFE_COLORS = {
        blade: '#cbd5e1',
        bladeEdge: '#f8fafc',
        handle: '#1e293b',
        handleBolts: '#94a3b8'
      };

      // Types
      const GameState = {
        MENU: 'MENU',
        PLAYING: 'PLAYING',
        GAME_OVER: 'GAME_OVER'
      };

      // Simple egg puns fallback (no API dependency)
      const getEggPun = async (score) => {
        const puns = [
          "Egg-cellent effort!",
          "That's un-shell-ievable!",
          "Don't crack under pressure!",
          "You're egg-stra special!",
          "Sunny side up next time!",
          "Don't put all your eggs in one basket!",
          "That was egg-citing!",
          "Shell we try again?",
          "You're on a roll... or should I say yolk?",
          "Scrambled but not beaten!",
          "Omelet you try again!",
          "Don't get fried up about it!",
          "Poached but not defeated!",
          "Hard-boiled determination!",
          "Whisked away too soon!"
        ];
        
        // Add score-based puns
        if (score === 0) return "Don't egg-nore practice!";
        if (score < 5) return "Keep trying, you'll crack it!";
        if (score < 10) return "You're getting egg-stra good!";
        if (score < 20) return "That's egg-ceptional progress!";
        if (score >= 20) return "You're absolutely egg-straordinary!";
        
        return puns[Math.floor(Math.random() * puns.length)];
      };

      // Background Component
      const Background = ({ isPlaying }) => {
        const [offset, setOffset] = useState(0);

        useEffect(() => {
          if (!isPlaying) return;
          let frame = requestAnimationFrame(function animate() {
            setOffset(prev => (prev + 0.5) % 1000);
            frame = requestAnimationFrame(animate);
          });
          return () => cancelAnimationFrame(frame);
        }, [isPlaying]);

        return (
          <div className="absolute inset-0 z-0 overflow-hidden bg-gradient-to-b from-sky-300 to-sky-100">
            <div className="absolute top-12 right-12 w-20 h-20 bg-yellow-200 rounded-full blur-[2px] shadow-[0_0_40px_rgba(253,224,71,0.5)]" />
            
            <div 
              className="absolute top-20 flex w-[2000px]"
              style={{ transform: `translateX(${-offset * 0.2}px)` }}
            >
              {[...Array(10)].map((_, i) => (
                <div key={i} className="w-32 h-10 bg-white/40 rounded-full blur-sm mx-20" />
              ))}
            </div>

            <div 
              className="absolute top-48 flex w-[2000px]"
              style={{ transform: `translateX(${-offset * 0.8}px)` }}
            >
              {[...Array(10)].map((_, i) => (
                <div key={i} className="w-48 h-14 bg-white/60 rounded-full blur-[1px] mx-32" />
              ))}
            </div>

            <div 
              className="absolute bottom-20 flex w-[4000px] opacity-40"
              style={{ transform: `translateX(${-offset * 0.4}px)` }}
            >
              {[...Array(20)].map((_, i) => (
                <div key={i} className="w-[400px] h-60 bg-green-600 rounded-t-[100%] -ml-20" />
              ))}
            </div>

            <div 
              className="absolute bottom-10 flex w-[4000px]"
              style={{ transform: `translateX(${-offset * 1.2}px)` }}
            >
              {[...Array(20)].map((_, i) => (
                <div key={i} className="w-[300px] h-40 bg-green-500 rounded-t-[100%] -ml-10 shadow-lg" />
              ))}
            </div>
          </div>
        );
      };

      // GameCanvas Component
      const GameCanvas = ({ gameState, onGameOver, onScoreUpdate, gameDimensions }) => {
        const canvasRef = useRef(null);
        const [eggY, setEggY] = useState(gameDimensions.height / 2);
        const [velocity, setVelocity] = useState(0);
        const [pipes, setPipes] = useState([]);
        const [score, setScore] = useState(0);
        const [shake, setShake] = useState(0);
        const [meltProgress, setMeltProgress] = useState(0);
        const [isDying, setIsDying] = useState(false);
        
        const particles = useRef([]);
        const frameRef = useRef();
        const lastPipeSpawn = useRef(0);
        const animationTimer = useRef(0);
        const dieStartTime = useRef(0);

        const createParticles = (x, y, color = 'white', count = 5, speedMod = 1) => {
          for (let i = 0; i < count; i++) {
            particles.current.push({
              x,
              y,
              vx: (Math.random() - 0.5) * 6 * speedMod,
              vy: (Math.random() - 0.5) * 6 * speedMod,
              life: 1.0,
              size: Math.random() * 8 + 4,
              color
            });
          }
        };

        const jump = useCallback(() => {
          if (gameState === GameState.PLAYING && !isDying) {
            setVelocity(JUMP_STRENGTH);
            createParticles(gameDimensions.width / 4, eggY + 10, '#FFF8E7', 8);
          }
        }, [gameState, isDying, gameDimensions.width, eggY]);

        useEffect(() => {
          const handleKeyDown = (e) => {
            if (e.code === 'Space') {
              e.preventDefault();
              jump();
            }
          };
          const handleTouch = (e) => {
            if (gameState === GameState.PLAYING) {
              jump();
            }
          };

          window.addEventListener('keydown', handleKeyDown);
          window.addEventListener('mousedown', handleTouch);
          window.addEventListener('touchstart', handleTouch, { passive: false });

          return () => {
            window.removeEventListener('keydown', handleKeyDown);
            window.removeEventListener('mousedown', handleTouch);
            window.removeEventListener('touchstart', handleTouch);
          };
        }, [jump, gameState]);

        useEffect(() => {
          if (gameState === GameState.PLAYING) {
            setEggY(gameDimensions.height / 2);
            setVelocity(0);
            setPipes([]);
            setScore(0);
            setShake(0);
            setMeltProgress(0);
            setIsDying(false);
            dieStartTime.current = 0;
            particles.current = [];
            lastPipeSpawn.current = performance.now();
          }
        }, [gameState, gameDimensions.height]);

        const update = useCallback((time) => {
          if (gameState === GameState.MENU) return;

          animationTimer.current = time;

          if (isDying) {
            if (dieStartTime.current === 0) dieStartTime.current = time;
            const elapsed = time - dieStartTime.current;
            const progress = Math.min(1, elapsed / 1000);
            setMeltProgress(progress);

            if (progress >= 1 && gameState !== GameState.GAME_OVER) {
              onGameOver(score);
            }

            if (Math.random() > 0.7) {
              createParticles(gameDimensions.width / 4, eggY, 'rgba(255,248,231,0.5)', 1, 0.3);
            }

            particles.current.forEach(p => {
              p.x += p.vx;
              p.y += p.vy;
              p.life -= 0.02;
            });
            particles.current = particles.current.filter(p => p.life > 0);
            frameRef.current = requestAnimationFrame(update);
            return;
          }

          if (gameState !== GameState.PLAYING) {
            frameRef.current = requestAnimationFrame(update);
            return;
          }

          if (shake > 0) setShake(s => Math.max(0, s - 0.5));

          setEggY(prevY => {
            const newY = prevY + velocity;
            setVelocity(v => v + GRAVITY);

            if (newY + EGG_RADIUS >= gameDimensions.height - GROUND_HEIGHT || newY - EGG_RADIUS <= 0) {
              setShake(SHAKE_INTENSITY);
              createParticles(gameDimensions.width / 4, newY, '#FFF8E7', 20, 2);
              setIsDying(true);
              return prevY;
            }
            return newY;
          });

          particles.current.forEach(p => {
            p.x += p.vx;
            p.y += p.vy;
            p.life -= 0.02;
          });
          particles.current = particles.current.filter(p => p.life > 0);

          if (time - lastPipeSpawn.current > 1600) {
            const minHeight = 100;
            const maxH = gameDimensions.height - GROUND_HEIGHT - PIPE_GAP - minHeight;
            const topHeight = Math.floor(Math.random() * (maxH - minHeight + 1)) + minHeight;
            setPipes(prev => [...prev, { x: gameDimensions.width, topHeight, passed: false }]);
            lastPipeSpawn.current = time;
          }

          setPipes(prevPipes => {
            const newPipes = prevPipes
              .map(p => ({ ...p, x: p.x - PIPE_SPEED }))
              .filter(p => p.x + PIPE_WIDTH + 50 > -200);

            newPipes.forEach(pipe => {
              if (!pipe.passed && pipe.x + PIPE_WIDTH < gameDimensions.width / 4) {
                pipe.passed = true;
                setScore(s => {
                  const ns = s + 1;
                  onScoreUpdate(ns);
                  return ns;
                });
              }

              const eggX = gameDimensions.width / 4;
              const inPX = eggX + EGG_RADIUS - 10 > pipe.x && eggX - EGG_RADIUS + 10 < pipe.x + PIPE_WIDTH;
              const inTopPY = eggY - EGG_RADIUS + 10 < pipe.topHeight;
              const inBotPY = eggY + EGG_RADIUS - 10 > pipe.topHeight + PIPE_GAP;

              if (inPX && (inTopPY || inBotPY)) {
                setShake(SHAKE_INTENSITY);
                createParticles(eggX, eggY, '#FFF8E7', 25, 2.5);
                setIsDying(true);
              }
            });
            return newPipes;
          });

          frameRef.current = requestAnimationFrame(update);
        }, [gameState, velocity, eggY, gameDimensions, score, onGameOver, onScoreUpdate, shake, isDying]);

        useEffect(() => {
          frameRef.current = requestAnimationFrame(update);
          return () => {
            if (frameRef.current) cancelAnimationFrame(frameRef.current);
          };
        }, [update]);

        useEffect(() => {
          const canvas = canvasRef.current;
          if (!canvas) return;
          const ctx = canvas.getContext('2d');
          if (!ctx) return;

          ctx.save();
          if (shake > 0) ctx.translate((Math.random() - 0.5) * shake, (Math.random() - 0.5) * shake);

          ctx.clearRect(0, 0, canvas.width, canvas.height);

          particles.current.forEach(p => {
            ctx.globalAlpha = p.life;
            ctx.fillStyle = p.color;
            ctx.beginPath();
            ctx.arc(p.x, p.y, p.size * p.life, 0, Math.PI * 2);
            ctx.fill();
          });
          ctx.globalAlpha = 1.0;

          // Draw Knives
          pipes.forEach(pipe => {
            const drawKnife = (isTop) => {
              ctx.save();
              
              const baseY = isTop ? 0 : canvas.height - GROUND_HEIGHT;
              const tipY = isTop ? pipe.topHeight : pipe.topHeight + PIPE_GAP;
              const direction = isTop ? 1 : -1;
              const height = Math.abs(tipY - baseY);

              ctx.translate(pipe.x + PIPE_WIDTH / 2, baseY);
              
              const bladeW = PIPE_WIDTH * 0.8;
              const bladeH = height - 40;
              
              ctx.save();
              ctx.translate(0, 40 * direction);

              ctx.beginPath();
              ctx.moveTo(-bladeW / 2, 0);
              ctx.lineTo(bladeW / 2, 0);
              ctx.lineTo(bladeW / 2, bladeH * 0.7 * direction);
              ctx.quadraticCurveTo(bladeW / 2, bladeH * direction, 0, bladeH * direction);
              ctx.lineTo(-bladeW / 2, 0);
              ctx.closePath();

              const grad = ctx.createLinearGradient(-bladeW / 2, 0, bladeW / 2, 0);
              grad.addColorStop(0, KNIFE_COLORS.blade);
              grad.addColorStop(0.5, KNIFE_COLORS.bladeEdge);
              grad.addColorStop(1, KNIFE_COLORS.blade);
              ctx.fillStyle = grad;
              ctx.fill();
              
              ctx.strokeStyle = '#64748b';
              ctx.lineWidth = 1;
              ctx.stroke();

              const glintPos = (Math.sin(animationTimer.current * 0.002) + 1) / 2;
              ctx.globalAlpha = 0.3;
              ctx.fillStyle = '#fff';
              ctx.fillRect(-bladeW/2 + (bladeW * glintPos), 0, 4, bladeH * direction);
              ctx.globalAlpha = 1.0;
              ctx.restore();

              const handleW = PIPE_WIDTH;
              const handleH = 45;
              ctx.fillStyle = KNIFE_COLORS.handle;
              ctx.beginPath();
              if (isTop) {
                ctx.roundRect(-handleW / 2, 0, handleW, handleH, 5);
              } else {
                ctx.roundRect(-handleW / 2, -handleH, handleW, handleH, 5);
              }
              ctx.fill();

              ctx.fillStyle = KNIFE_COLORS.handleBolts;
              const boltY = isTop ? handleH / 2 : -handleH / 2;
              ctx.beginPath(); ctx.arc(-handleW / 3, boltY, 3, 0, Math.PI * 2); ctx.fill();
              ctx.beginPath(); ctx.arc(0, boltY, 3, 0, Math.PI * 2); ctx.fill();
              ctx.beginPath(); ctx.arc(handleW / 3, boltY, 3, 0, Math.PI * 2); ctx.fill();

              ctx.restore();
            };

            drawKnife(true);
            drawKnife(false);
          });

          ctx.fillStyle = '#3e2723';
          ctx.fillRect(0, canvas.height - GROUND_HEIGHT, canvas.width, GROUND_HEIGHT);
          ctx.fillStyle = '#1b5e20';
          ctx.fillRect(0, canvas.height - GROUND_HEIGHT, canvas.width, 20);

          const eggX = canvas.width / 4;
          ctx.save();
          ctx.translate(eggX, eggY);
          
          let stretch, squash;
          if (isDying) {
            stretch = 1 - meltProgress * 0.85;
            squash = 1 + meltProgress * 3.0;
            ctx.translate(0, EGG_RADIUS * meltProgress);
            ctx.globalAlpha = 1 - meltProgress * 0.4;
          } else {
            stretch = 1 + Math.abs(velocity) * 0.03;
            squash = 1 / stretch;
            ctx.rotate(Math.min(Math.PI / 4, Math.max(-Math.PI / 4, velocity * 0.08)));
          }
          
          ctx.scale(squash, stretch);
          
          ctx.beginPath();
          ctx.ellipse(0, 0, EGG_RADIUS * 0.85, EGG_RADIUS, 0, 0, Math.PI * 2);
          const eggGrad = ctx.createRadialGradient(-5, -5, 2, 0, 0, EGG_RADIUS);
          
          if (isDying) {
            eggGrad.addColorStop(0, '#FFFFFF');
            eggGrad.addColorStop(0.4, '#fffde7');
            eggGrad.addColorStop(1, '#ffeb3b');
          } else {
            eggGrad.addColorStop(0, '#FFFFFF');
            eggGrad.addColorStop(1, '#FFF8E7');
          }
          
          ctx.fillStyle = eggGrad;
          ctx.strokeStyle = isDying ? '#D4A373' : '#D4A373';
          ctx.lineWidth = 3;
          ctx.fill();
          ctx.stroke();

          if (meltProgress < 0.5) {
            ctx.fillStyle = '#000';
            ctx.globalAlpha = 1 - (meltProgress * 2.5);
            ctx.beginPath(); ctx.arc(8, -6, 2.5, 0, Math.PI * 2); ctx.fill();
            ctx.beginPath(); ctx.arc(-2, -6, 2.5, 0, Math.PI * 2); ctx.fill();
          }

          ctx.restore();
          ctx.restore();

        }, [eggY, pipes, velocity, gameDimensions, shake, gameState, meltProgress, isDying]);

        return (
          <canvas
            ref={canvasRef}
            width={gameDimensions.width}
            height={gameDimensions.height}
            className="block mx-auto max-w-full h-auto bg-transparent relative z-10 cursor-pointer"
          />
        );
      };

      // Main App Component
      const App = () => {
        const [gameState, setGameState] = useState(GameState.MENU);
        const [score, setScore] = useState(0);
        const [highScore, setHighScore] = useState(() => Number(localStorage.getItem('flappyEggHighScore')) || 0);
        
        const [pun, setPun] = useState("");
        const [loadingPun, setLoadingPun] = useState(false);
        const [isScoreBouncing, setIsScoreBouncing] = useState(false);
        const [dimensions, setDimensions] = useState({
          width: window.innerWidth > 500 ? 400 : window.innerWidth,
          height: window.innerHeight > 800 ? 700 : window.innerHeight
        });

        useEffect(() => {
          localStorage.setItem('flappyEggHighScore', highScore.toString());
        }, [highScore]);

        useEffect(() => {
          const handleResize = () => {
            setDimensions({
              width: window.innerWidth > 500 ? 400 : window.innerWidth,
              height: window.innerHeight > 800 ? 700 : window.innerHeight
            });
          };
          window.addEventListener('resize', handleResize);
          return () => window.removeEventListener('resize', handleResize);
        }, []);

        const startGame = useCallback(() => {
          setGameState(GameState.PLAYING);
          setScore(0);
          setPun("");
        }, []);

        useEffect(() => {
          const handleGlobalKey = (e) => {
            if (e.code === 'Space') {
              if (gameState === GameState.MENU || gameState === GameState.GAME_OVER) {
                e.preventDefault();
                startGame();
              }
            }
          };
          window.addEventListener('keydown', handleGlobalKey);
          return () => window.removeEventListener('keydown', handleGlobalKey);
        }, [gameState, startGame]);

        const handleGameOver = useCallback(async (finalScore) => {
          setGameState(GameState.GAME_OVER);
          if (finalScore > highScore) {
            setHighScore(finalScore);
          }
          
          setLoadingPun(true);
          const result = await getEggPun(finalScore);
          setPun(result);
          setLoadingPun(false);
        }, [highScore]);

        const handleScoreUpdate = useCallback((newScore) => {
          setScore(newScore);
          setIsScoreBouncing(true);
          setTimeout(() => setIsScoreBouncing(false), 200);
        }, []);

        return (
          <div className="relative w-screen h-screen flex items-center justify-center bg-gray-950 select-none touch-none overflow-hidden text-slate-900">
            <div 
              className="relative bg-white shadow-[0_0_100px_rgba(0,0,0,0.8)] overflow-hidden rounded-3xl"
              style={{ width: dimensions.width, height: dimensions.height }}
            >
              <Background isPlaying={gameState === GameState.PLAYING} />
              
              <GameCanvas 
                gameState={gameState}
                onGameOver={handleGameOver}
                onScoreUpdate={handleScoreUpdate}
                gameDimensions={dimensions}
              />

              {gameState === GameState.PLAYING && (
                <div className={`absolute top-12 left-0 w-full text-center z-20 pointer-events-none transition-transform duration-200 ${isScoreBouncing ? 'scale-125' : 'scale-100'}`}>
                  <h1 className="text-7xl font-game text-white drop-shadow-[0_6px_0_rgba(0,0,0,0.3)]">
                    {score}
                  </h1>
                </div>
              )}

              {gameState === GameState.MENU && (
                <div className="absolute inset-0 bg-black/30 backdrop-blur-[2px] flex flex-col items-center justify-center z-30 p-6 text-center animate-in fade-in duration-500">
                  <div className="bg-white/90 p-10 rounded-[40px] shadow-2xl border-b-[10px] border-orange-100 transform hover:scale-105 transition-transform duration-300 w-full max-w-[320px]">
                    <div className="mb-4 inline-block animate-bounce">
                       <div className="w-16 h-20 bg-white border-4 border-orange-200 rounded-[50%] mx-auto shadow-inner relative overflow-hidden">
                          <div className="absolute inset-0 bg-gradient-to-tr from-[#FFF8E7] to-white" />
                          <div className="absolute top-4 left-4 w-2 h-2 bg-black rounded-full" />
                          <div className="absolute top-4 right-4 w-2 h-2 bg-black rounded-full" />
                       </div>
                    </div>
                    <h1 className="text-5xl font-game text-orange-600 mb-2 tracking-tight uppercase">Flappy Egg</h1>
                    <p className="text-orange-900/60 font-bold mb-6 italic text-sm">Don't Get Over Easy!</p>
                    
                    <div className="flex flex-col gap-3">
                      <button 
                        onClick={startGame}
                        className="bg-orange-600 hover:bg-orange-500 text-white font-game text-2xl py-4 rounded-2xl shadow-[0_6px_0_#9a3412] active:translate-y-2 active:shadow-none transition-all"
                      >
                        START (SPACE)
                      </button>
                      <div className="mt-4 pt-4 border-t border-orange-100">
                         <p className="text-orange-900/60 font-bold text-xs uppercase tracking-widest">Global Best</p>
                         <p className="text-orange-600 font-game text-3xl">{highScore}</p>
                      </div>
                    </div>
                  </div>
                </div>
              )}

              {gameState === GameState.GAME_OVER && (
                <div className="absolute inset-0 bg-orange-950/70 backdrop-blur-md flex flex-col items-center justify-center z-30 p-6">
                  <div className="bg-white w-full max-w-[320px] p-8 rounded-[50px] shadow-2xl border-b-[12px] border-orange-100 text-center flex flex-col gap-5 animate-in slide-in-from-bottom-20 duration-500">
                    <h2 className="text-5xl font-game text-orange-800 -rotate-2 leading-tight">MELTED!</h2>
                    
                    <div className="bg-orange-50 p-6 rounded-[30px] border-2 border-orange-100 relative">
                      <p className="text-xs uppercase tracking-[0.2em] text-orange-400 font-black mb-1">Score</p>
                      <p className="text-7xl font-game text-orange-800 leading-none mb-4">{score}</p>
                      
                      <div className="pt-3 border-t-2 border-orange-200/50">
                        <p className="text-[10px] uppercase tracking-widest text-orange-400 font-black">Personal Best</p>
                        <p className="text-3xl font-game text-orange-600">{highScore}</p>
                      </div>
                    </div>

                    <div className="min-h-[70px] flex items-center justify-center bg-gray-50 rounded-2xl p-3 border border-gray-100">
                      {loadingPun ? (
                        <div className="flex gap-2">
                          <div className="w-3 h-3 bg-orange-300 rounded-full animate-bounce" />
                          <div className="w-3 h-3 bg-orange-400 rounded-full animate-bounce [animation-delay:0.1s]" />
                          <div className="w-3 h-3 bg-orange-500 rounded-full animate-bounce [animation-delay:0.2s]" />
                        </div>
                      ) : (
                        <p className="text-orange-600 font-bold italic text-base leading-snug">"{pun}"</p>
                      )}
                    </div>

                    <button 
                      onClick={startGame}
                      className="bg-orange-800 hover:bg-orange-700 text-white font-game text-2xl py-4 rounded-2xl shadow-[0_8px_0_#4e342e] active:translate-y-2 active:shadow-none transition-all"
                    >
                      RE-SHELL (SPACE)
                    </button>
                  </div>
                </div>
              )}
            </div>
          </div>
        );
      };

      // Render the app
      const root = ReactDOM.createRoot(document.getElementById('root'));
      root.render(<App />);
    </script>
</body>
</html>
